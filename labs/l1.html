<html>
<head>
	<meta charset="utf-8">
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, content=no-cache">

	<!-- Bootstrap CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css" integrity="sha384-Zug+QiDoJOrZ5t4lssLdxGhVrurbmBWopoEl+M6BdEfwnCJZtKxi1KgxUyJq13dy" crossorigin="anonymous">
	<link rel="stylesheet" href="../sty2.css">

  <title>Computer Systems Organization (Fall 2020) </title>
</head>

<body>
<br>
    <main role="main" class="container">
      <header class="header clearfix">
        <nav>
          <ul class="nav nav-pills float-left">
            <li class="nav-item">
              <a class="nav-link " href="../index.html">Home <span class="sr-only">(current)</span></a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../schedule.html">Schedule</a>
            </li>
            <li class="nav-item">
              <a class="nav-link active" href=".">Lab</a>
            </li>
          </ul>
        </nav>
	<div class="row">
		<div class="col-sm-3"><img src="../org.png" width=150></div>
		<div class="col-sm-9">
		<div class="row">
        <h3 class="text-muted">Computer Systems Organization</h3>
		</div>
		<div class="row">
			CSCI-UA.0201(007), Fall 2020
		</div>
		</div>
	</div>
      </header>

<div id="content">
<hr>

<h2> Lab-1: Basic C Programming</h2>

<p>
The goal of this lab is to get your hands dirty doing some basic C programming
and debugging. There are two components to this lab. First, you 
write a series of simple C functions in programs whose skeleton code are already provided 
for you. Next, you write complete C programs by yourself from the scratch.

<p>
<div class="bd-callout bd-callout-warning">
	<h5>Before you start the lab:</h5>
	<p><a href="index.html#vm">Set up</a> your VM environment. If you hit problems, read through <a href="index.html#vm-faq">Virtubox FAQs</a>.
	<p>
	<a href="index.html#repo">Set up</a> your lab git repository. Read through <a href="index.html#git-faq">git FAQs</a>.
	</ul>
</div>

<p>
<div class="bd-callout bd-callout-warning">
	<h5>Programming style:</h5>
	<p>In this and subsequent labs, you will be graded for style and we will deduct up to 20% of total lab points for bad style based on our subjective evaluation. Please read this <a href="http://cs61.seas.harvard.edu/wiki/2015/Style">style guide</a> and follow the advice.
</div>

<h3 id="c1">Mini-exercises: Part1-8 (100 points)</h3>
<p> First, click on Lab1's github classroom invitation link (posted in Piazza) and select your NYU email address.  Next, clone your repo by typing the following
<pre >
$ cd cso-labs
$ git clone https://github.com/nyu-cso-fa19/lab1-&lt;YourGithubUsername&gt;.git  lab1
</pre>


<p>For the series of mini-exercises on C, you shall complete the files 
<tt>part1.c</tt>, <tt>part2.c</tt>, <tt>...</tt>, <tt>part8.c</tt>, found in subdirectory <tt>mini/</tt>  

<div class="bd-callout bd-callout-danger"><h5>File modification</h5> For the mini-exercises,
the only files that you should modify are <tt>part1.c</tt>, <tt>part2.c</tt>, ..., <tt>part8.c</tt>.
You may read other files but you must not change them.</tt></span>.
</div>

<p>
It is recommended that you complete and test each exercise individually. For example, suppose you have completed 
the exercise in <tt>part1.c</tt>.  Test by typing the following:
<pre >
$ make
$ build/part1
variable should be 5, actually is 3!
Aborted
</pre>

From the above error message, you can see that it did not pass the test. Debug and try again.
Complete and test each part individually before moving on to the next one.

<p>Once you've passed the tests for all 8 exercises in <tt>mini/</tt>, you can double check your test-passing status by typing:
<pre >
$ ./grade-lab
basic [part1.c]: 
  set_to_five: OK
  array_sum: OK
bubble sort [part2.c]: 
  swap: OK
  bubble_sort: OK
prime sieves [part3.c]: 
  initialize_array: OK
  mark_multiples: OK
  prime_number_sieves: OK
  find_smallest_divisor: OK
point structure [part4.c]: 
  set_point: OK
  point_dist: OK
linked list [part5.c]: 
  list_insert: OK
  list_end: OK
  list_size: OK
  list_find: OK
  list_remove: OK
bitwise operators [part6.c]: 
  get_exponent_field: OK
  clear_msb: OK
  bit_at_index: OK
binary tree [part7.c]: 
  preorder_traveral: OK
  inorder_traversal: OK
  inorder_traversal_with_dup: OK
split string [part8.c]: 
  easy_string_split: OK
  harder_string_split: OK
Score: 100/100
</pre>
The above shows the example output of a successful full test.

<p>

<h4>Saving changes while you are working on Lab1</h4>
You should frequently save your 
work to protect against laptop failures and other unforeseen troubles. 
You save the changes by first "committing" them to your local lab repo and then "pushing" 
those changes to the repo stored on github.com
<p>
<pre >
$ git commit -am "saving lab1 changes"
$ git push origin master
</pre>

<p>The `-a` flag (as in the command `git commit -am ...`) tells git to add the changes you've made to existing files to the current commit.
If you do not provide this flag, the changes you made to the existing files will not be committed.
After you've pushed your changes with <kbd>git push</kbd>, they are safely stored on github.com.
Even if your laptop catches on fire in the future, those pushed changes can still be retrieved.
However, you must remember that <kbd>git commit</kbd> by itself does not save your changes on github.com 
(it only saves your changes locally).  So, don't forget to type that <kbd>git
  push origin master</kbd>.

<p>
<h4 id="debug">Debugging the lab</h4>

Below are some advice on how to debug common problems encountered in doing this lab:

<ul>
	<li><b>Remember to recompile changed code</b>. Whenever you've changed a file, always type <kbd>make</kbd> to re-compile before executing again.</li>

	<li><b>Write your own simple test code.</b> Don't rely solely on the lab's testing infrastructure (i.e. <tt>./grade-lab</tt>) to test the correctness of your code.  Except for 
	part7, we do not distribute the source of the test code (hence you will only see <tt>cso-labs/clab/mini/static/part1_harness.o</tt> and not <tt>cso-labs/clab/mini/static/part1_harness.c</tt>). 
	This makes it hard to debug. So you should write your own tester.
	<p>
	<p>Let's say you want to test the <tt>array_sum</tt> function in file <tt>part1.c</tt>. To write your own test code, create a file (e.g. called <tt>test-part1.c</tt>) with a <tt>main</tt> function that invokes <tt>array_sum</tt> in various ways to test its correctness. 
<p>An example <tt>test-part1.c</tt> might look something like <a href="labs/test_part1.c">this</a>.
<p>Compile your test code by typing:
<pre >
$ gcc -std=gnu99 test_part1.c part1.c
</pre>

<li><b>Read part7_harness.c test code.</b> For part7, we distribute the source of the tester code in <tt>part7_harness.c</tt>. It'll be very helpful for 
	debugging if you read this file.
	<li><b>Learn to use <tt>gdb</tt></b>.  It is absolutely essential that you learn to use <tt>gdb</tt>. This tool is a must for helping you handle ``segmentation fault'',
		which you'll see a lot when doing labs.  Let's say you have a segfault on part1. Invoke <tt>gdb</tt> by typing:
		<p>
<pre >
$ gdb build/part1
(gdb) bt
</pre>
<tt>bt</tt> is the gdb command to print the stack trace which tells you where the problematic execution occurs and how the program got there.
<a href="https://github.com/nyu-cso-fa16/recitation02#debug">Recitation 2</a> has covered the use of gdb.  There are also many tutorials online on gdb.
</ul>
 
<h3 id="c2"> Write standalone C programs from scratch</h3>
<p>In this second component of the lab, we provide no crutches 
(no skeleton code, no Makefile, no grading testers) to make you get comfortable with the overall experience of writing C programs and testing them on UNIX. 
You are to write one standard alone C program from scratch.

<p>
<div class="bd-callout bd-callout-danger">
	<h5>Output format:</h5>
	<p> Now that you are writing a stand-alone program, you need to pay special
  attention to the output format of your program since when we grade your labs,
  we only compare the output. So your output must be exactly the same as our
  standard solution. <b>If your output format is wrong, there won't be partial
    scores</b>.

  <p> Therefore, the very important thing to keep in mind is read carefully the
  instructions below and understand what the output should be. You need to
  strictly follow our requirements on output format. If you have questions
  about the output format, ask on Piazza.

  <p> And, we provide you with a simple script in lab repository to check your
  output for <tt>avgcsv</tt> and <tt>gameoflife</tt>. To use the checker,
  first change to the scratch folder by <kbd>cd clab/scratch</kbd>, and then
  <kbd>./output_format_checker.sh</kbd>. If the checker does not report error,
  then your output format is good.
</div>

<p>
<h5 id="e1">Standalone C program: Averaging columns in a *.csv file (25 points)</h5>
<p>Put all your files for this exercise in <tt>cso-labs/clab/scratch/avgcsv</tt> directory.

<p>Write a C program that parses a *.csv file print out the average of each
column. The input csv file has a set of columns separated by the ';' character.
Each columns contains a whole or fractional number.  

<p>Your executable file must be named <tt>avgcsv</tt>. It should take as
argument the name of a csv file and outputs the average of each column (with 2
digits of precision), separated by ';'.

<p>For example, suppose the contents of the <tt>example.csv</tt> are as follows:
<pre>
$ cat example.csv   
10;25.5;56
22;10;100.4
</pre>

<p>Then, the expected output of the command <kbd>./avgcsv example.csv</kbd> should be:
<pre>
$ ./avgcsv example.csv
16.00;17.75;78.20
</pre>

<p>We expect you to write a Makefile to generate the <tt>avgcsv</tt> executable file from your source code. 
<a href="https://github.com/nyu-cso-fa19/cso19-recitation/blob/master/r02/r02.pdf">Recitation 2</a> teaches you how to write a Makefile.

<p>There are some simple test cases under
<tt>cso-labs/clab/scratch/simple_test_cases</tt>, but we do not provide you with all tests and will test your program under a few *.csv files of our own choosing during grading time. 
You should write unit tests for your program. In particular, you should test the cases when the input csv file contains a 
large number of rows or a large number of columns. You can assume that you
won't run out of memory storing all the floating points parsed from the file in the memory.

<p>Once finished, add relevant source files and Makefile to your git repo by typing <kbd>git add *.c *.h Makefile</kbd>. 
Commit and push <kbd>git commit -am "avgcsv"; git push origin master</kbd>
<p>Note that whenever you add a new file in this directory, you need to manually tell git to ``track it'' with 
<kbd>git add</kbd>.  Otherwise, the file will not be committed by <tt>git commit</tt>. 

<p>Some advice on doing this lab:
<ul>
	<li><b>Use either <tt>strtok_r</tt> from C library, or <tt>string_token</tt> you implemented in part8.c of minilab</b> to split into columns.
		If you decide to use the former, read its documentation <kbd>man strtok_r</kbd>, and compile your program with gcc flag `<tt>gcc -std=gnu99</tt>`. If you decide to use the latter, include the header file with <tt>#include "../../mini/part8.h"</tt>, and link your program with part8.o from the mini/ directory.
		<li><b>Use printf("%.2f", number)</b> to print a number to the precision of 2 decimal points.
	<li><b>Write good tests.</b> In your unit tests, you should test with csv files with different rows and columns. Make sure you test cases when the input csv file contains a 
large number of rows or a large number of columns. You can assume that you
won't run out of memory storing all the floating points parsed from the file in the memory.
	<li><b>Pay attention to coding style</b>. Do not write all your code in one giant <tt>main</tt> function. Break your program logic into several smaller functions.
</ul>

<p>Once you finished <tt>avgcsv</tt>, you may either elect to do the bonus exercise below, or proceed to <a href="#handin">hand in the lab</a>.

<h5 id="e3">Bonus exercise: Game of Life (25 points) </h5>

<p>This is a bonus exercise, and thus not mandatory. 

<p>Put all your files for this exercise in <tt>cso-labs/clab/scratch/gameoflife</tt> directory.

<p>Write a C program to simulate the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway's game of life</a>.

<p>In a game of life of size n by n, the universe is two dimensional and consists of n by n cells.
Each cell is in one of two possible states, "live"/"dead" (or "populated"/"unpopulated").
Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:
<ul>
	<li>Any live cell with fewer than two live neighbours dies, as if caused by under-population.
	<li>Any live cell with two or three live neighbours lives on to the next generation.
	<li>Any live cell with more than three live neighbours dies, as if by over-population.
	<li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
</ul>

<p>
The initial pattern constitutes the seed of the system. The first generation is created by applying the above rules <i>simultaneously</i> to every cell in the seed; births and deaths occur simultaneously, and the discrete moment at which this happens is sometimes called a tick. The rules continue to be applied repeatedly to create further generations.

<p>What about boundary conditions? We treat the borders of the 2D world as if they wrap around. 
In a universe of n x n cells, let's refer to the top-left cell as in position (0,0) and the bottom right cell as in position (n-1,n-1).  If borders wrap around, then the 8 neighbors of (i,j) are:
<ol>
	<li><tt>((i+1)%n,j)</tt> right neighbor
	<li><tt>((i-1)%n,j)</tt> left neighbor
	<li><tt>(i,(j+1)%n)</tt> top neighbor
	<li><tt>(i,(j-1)%n)</tt> bottom neighbor
	<li><tt>((i+1)%n,(j+1)%n)</tt> topright neighbor
	<li><tt>((i-1)%n,(j+1)%n)</tt> topleft neighbor
	<li><tt>((i+1)%n,(j-1)%n)</tt> bottomright neighbor
	<li><tt>((i-1)%n,(j-1)%n)</tt> bottomleft neighbor
</ol>
<p>
Your executable file must be named <tt>gameoflife</tt>. 
It should take two arguments. The first argument is the name of a seed pattern file. 
The second argument is the number of ticks to run for the simulation.
The seed pattern file contains one line per row of the universe. If the cell is "dead", 
its position is marked with the '.' character. If the cell is "live", the position is 
marked with the 'x' character. The seed file also effectively specifies the size of the 
universe to simulate.
 
<p>For example, the contents of an example seed file <tt>example_seed</tt> are as follows:
<pre>
$ cat example_seed
.....
.....
.xxx.
.....
.....
</pre>

Then, the expected output of the command <kbd>./gameoflife example_seed 1</kbd> should be:
<pre>
$ ./gameoflife example_seed 1
.....
..x..
..x..
..x..
.....
</pre>

The expected output of the command <kbd>./gameoflife example_seed 2</kbd> should be:
<pre>
$ ./gameoflife example_seed 2
.....
.....
.xxx.
.....
.....
</pre>

<p>Like in exercise 1 and 2, you should write a Makefile to compile your program and write your 
own unit tests to check the correctness.  During grading, we'll test your program using seed files of our own choosing.  <span class=text-info>You may assume that the seed file used for testing contains a world of no more than 1000x1000</p>

<p>Once finished, add relevant source files and Makefile to your git repo by typing <kbd>git add *.c *.h Makefile</kbd>. 
Commit and push <kbd>git commit -am "gameoflife"; git push origin master</kbd>

<h4 id="handin">Handin Procedure</h4>

To handin your files, simply commit and push them to github.com 
<p>
<pre >
$ git commit -am "hand in lab1"
$ git push origin master
</pre>

We will fetching your lab files from Github.com at the specified deadline and grade them.

<p>
<hr>
</html>
